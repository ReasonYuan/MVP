//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/liaomin/Documents/workspace/Android/DocPlusLogic/src/com/fq/lib/json/JSONTokener.java
//
//  Created by liaomin on 15-5-4.
//

#line 1 "/Users/liaomin/Documents/workspace/Android/DocPlusLogic/src/com/fq/lib/json/JSONTokener.java"

#include "IOSClass.h"
#include "JSONArray.h"
#include "JSONException.h"
#include "JSONObject.h"
#include "JSONTokener.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"


#line 62
@implementation FQJSONTokener


#line 78
- (id)initWithNSString:(NSString *)inArg {
  if (self = [super init]) {
    
#line 80
    if (inArg != nil && [inArg hasPrefix:@"\ufeff"]) {
      inArg = [inArg substring:1];
    }
    
#line 83
    self->in_ = inArg;
  }
  return self;
}


#line 93
- (id)nextValue {
  
#line 94
  int c = [self nextCleanInternal];
  switch (c) {
    case -1:
    @throw [self syntaxErrorWithNSString:@"End of input"];
    
#line 99
    case '{':
    return [self readObject];
    
#line 102
    case '[':
    return [self readArray];
    
#line 105
    case '\'':
    case '"':
    return [self nextStringWithChar:(unichar) c];
    
#line 109
    default:
    pos_--;
    return [self readLiteral];
  }
}


#line 115
- (int)nextCleanInternal {
  
#line 116
  while (pos_ < ((int) [((NSString *) nil_chk(in_)) length])) {
    int c = [in_ charAtWithInt:pos_++];
    {
      
#line 130
      unichar peek;
      
#line 118
      switch (c) {
        case 0x0009:
        case ' ':
        case 0x000a:
        case 0x000d:
        continue;
        
#line 125
        case '/':
        if (pos_ == ((int) [in_ length])) {
          return c;
        }
        
#line 130
        peek = [in_ charAtWithInt:pos_];
        {
          
#line 135
          int commentEnd;
          
#line 131
          switch (peek) {
            case '*':
            
#line 134
            pos_++;
            commentEnd = [in_ indexOfString:@"*/" fromIndex:pos_];
            if (commentEnd == -1) {
              @throw [self syntaxErrorWithNSString:@"Unterminated comment"];
            }
            pos_ = commentEnd + 2;
            continue;
            
#line 142
            case '/':
            
#line 144
            pos_++;
            [self skipToEndOfLine];
            continue;
            
#line 148
            default:
            return c;
          }
        }
        case '#':
        
#line 158
        [self skipToEndOfLine];
        continue;
        
#line 161
        default:
        return c;
      }
    }
  }
  return -1;
}


#line 174
- (void)skipToEndOfLine {
  
#line 175
  for (; pos_ < ((int) [((NSString *) nil_chk(in_)) length]); pos_++) {
    unichar c = [in_ charAtWithInt:pos_];
    if (c == 0x000d || c == 0x000a) {
      pos_++;
      break;
    }
  }
}


#line 194
- (NSString *)nextStringWithChar:(unichar)quote {
  
#line 200
  JavaLangStringBuilder *builder = nil;
  
#line 203
  int start = pos_;
  
#line 205
  while (pos_ < ((int) [((NSString *) nil_chk(in_)) length])) {
    int c = [in_ charAtWithInt:pos_++];
    if (c == quote) {
      if (builder == nil) {
        
#line 210
        return [NSString stringWithString:[in_ substring:start endIndex:pos_ - 1]];
      }
      else {
        
#line 212
        (void) [builder appendWithJavaLangCharSequence:in_ withInt:start withInt:pos_ - 1];
        return [builder description];
      }
    }
    
#line 217
    if (c == '\\') {
      if (pos_ == ((int) [in_ length])) {
        @throw [self syntaxErrorWithNSString:@"Unterminated escape sequence"];
      }
      if (builder == nil) {
        builder = [[JavaLangStringBuilder alloc] init];
      }
      (void) [((JavaLangStringBuilder *) nil_chk(builder)) appendWithJavaLangCharSequence:in_ withInt:start withInt:pos_ - 1];
      (void) [builder appendWithChar:[self readEscapeCharacter]];
      start = pos_;
    }
  }
  
#line 230
  @throw [self syntaxErrorWithNSString:@"Unterminated string"];
}


#line 242
- (unichar)readEscapeCharacter {
  
#line 243
  unichar escaped = [((NSString *) nil_chk(in_)) charAtWithInt:pos_++];
  {
    
#line 249
    NSString *hex;
    
#line 244
    switch (escaped) {
      case 'u':
      if (pos_ + 4 > ((int) [in_ length])) {
        @throw [self syntaxErrorWithNSString:@"Unterminated escape sequence"];
      }
      hex = [in_ substring:pos_ endIndex:pos_ + 4];
      pos_ += 4;
      return (unichar) [JavaLangInteger parseIntWithNSString:hex withInt:16];
      
#line 253
      case 't':
      return 0x0009;
      
#line 256
      case 'b':
      return 0x0008;
      
#line 259
      case 'n':
      return 0x000a;
      
#line 262
      case 'r':
      return 0x000d;
      
#line 265
      case 'f':
      return 0x000c;
      
#line 268
      case '\'':
      case '"':
      case '\\':
      default:
      return escaped;
    }
  }
}


#line 281
- (id)readLiteral {
  
#line 282
  NSString *literal = [self nextToInternalWithNSString:@"{}[]/\\:,=;# \t\x0c"];
  
#line 284
  if (((int) [((NSString *) nil_chk(literal)) length]) == 0) {
    @throw [self syntaxErrorWithNSString:@"Expected literal value"];
  }
  else
#line 286
  if ([@"null" equalsIgnoreCase:literal]) {
    return FQJSONObject_get_NULL__();
  }
  else
#line 288
  if ([@"true" equalsIgnoreCase:literal]) {
    return JavaLangBoolean_get_TRUE__();
  }
  else
#line 290
  if ([@"false" equalsIgnoreCase:literal]) {
    return JavaLangBoolean_get_FALSE__();
  }
  
#line 295
  if ([literal indexOf:'.'] == -1) {
    int base = 10;
    NSString *number = literal;
    if ([number hasPrefix:@"0x"] || [number hasPrefix:@"0X"]) {
      number = [number substring:2];
      base = 16;
    }
    else
#line 301
    if ([number hasPrefix:@"0"] && ((int) [number length]) > 1) {
      number = [number substring:1];
      base = 8;
    }
    @try {
      long long int longValue = [JavaLangLong parseLongWithNSString:number withInt:base];
      if (longValue <= JavaLangInteger_MAX_VALUE && longValue >= JavaLangInteger_MIN_VALUE) {
        return [JavaLangInteger valueOfWithInt:(int) longValue];
      }
      else {
        
#line 310
        return [JavaLangLong valueOfWithLong:longValue];
      }
    }
    @catch (
#line 312
    JavaLangNumberFormatException *e) {
    }
  }
  
#line 322
  @try {
    return [JavaLangDouble valueOfWithNSString:literal];
  }
  @catch (
#line 324
  JavaLangNumberFormatException *ignored) {
  }
  
#line 328
  return [NSString stringWithString:literal];
}


#line 335
- (NSString *)nextToInternalWithNSString:(NSString *)excluded {
  
#line 336
  int start = pos_;
  for (; pos_ < ((int) [((NSString *) nil_chk(in_)) length]); pos_++) {
    unichar c = [in_ charAtWithInt:pos_];
    if (c == 0x000d || c == 0x000a || [((NSString *) nil_chk(excluded)) indexOf:c] != -1) {
      return [in_ substring:start endIndex:pos_];
    }
  }
  return [in_ substring:start];
}


#line 350
- (FQJSONObject *)readObject {
  
#line 351
  FQJSONObject *result = [[FQJSONObject alloc] init];
  
#line 354
  int first = [self nextCleanInternal];
  if (first == '}') {
    return result;
  }
  else
#line 357
  if (first != -1) {
    pos_--;
  }
  
#line 361
  while (YES) {
    id name = [self nextValue];
    if (!([name isKindOfClass:[NSString class]])) {
      if (name == nil) {
        @throw [self syntaxErrorWithNSString:@"Names cannot be null"];
      }
      else {
        
#line 367
        @throw [self syntaxErrorWithNSString:[NSString stringWithFormat:@"Names must be strings, but %@ is of type %@", name,
#line 368
        [[name getClass] getName]]];
      }
    }
    
#line 377
    int separator = [self nextCleanInternal];
    if (separator != ':' && separator != '=') {
      @throw [self syntaxErrorWithNSString:[NSString stringWithFormat:@"Expected ':' after %@", name]];
    }
    if (pos_ < ((int) [((NSString *) nil_chk(in_)) length]) && [in_ charAtWithInt:pos_] == '>') {
      pos_++;
    }
    
#line 385
    (void) [result putWithNSString:(NSString *) check_class_cast(name, [NSString class]) withId:[self nextValue]];
    
#line 387
    switch ([self nextCleanInternal]) {
      case '}':
      return result;
      case ';':
      case ',':
      continue;
      default:
      @throw [self syntaxErrorWithNSString:@"Unterminated object"];
    }
  }
}


#line 405
- (FQJSONArray *)readArray {
  
#line 406
  FQJSONArray *result = [[FQJSONArray alloc] init];
  
#line 409
  BOOL hasTrailingSeparator = NO;
  
#line 411
  while (YES) {
    switch ([self nextCleanInternal]) {
      case -1:
      @throw [self syntaxErrorWithNSString:@"Unterminated array"];
      case ']':
      if (hasTrailingSeparator) {
        (void) [result putWithId:nil];
      }
      return result;
      case ',':
      case ';':
      
#line 423
      (void) [result putWithId:nil];
      hasTrailingSeparator = YES;
      continue;
      default:
      pos_--;
    }
    
#line 430
    (void) [result putWithId:[self nextValue]];
    
#line 432
    switch ([self nextCleanInternal]) {
      case ']':
      return result;
      case ',':
      case ';':
      hasTrailingSeparator = YES;
      continue;
      default:
      @throw [self syntaxErrorWithNSString:@"Unterminated array"];
    }
  }
}


#line 449
- (FQJSONException *)syntaxErrorWithNSString:(NSString *)message {
  
#line 450
  return [[FQJSONException alloc] initWithNSString:[NSString stringWithFormat:@"%@%@", message, self]];
}

- (NSString *)description {
  
#line 458
  return [NSString stringWithFormat:@" at character %d of %@", pos_, in_];
}


#line 472
- (BOOL)more {
  
#line 473
  return pos_ < ((int) [((NSString *) nil_chk(in_)) length]);
}


#line 481
- (unichar)next {
  
#line 482
  return pos_ < ((int) [((NSString *) nil_chk(in_)) length]) ? [in_ charAtWithInt:pos_++] : 0x0000;
}


#line 489
- (unichar)nextWithChar:(unichar)c {
  
#line 490
  unichar result = [self next];
  if (result != c) {
    @throw [self syntaxErrorWithNSString:[NSString stringWithFormat:@"Expected %C but was %C", c, result]];
  }
  return result;
}


#line 503
- (unichar)nextClean {
  
#line 504
  int nextCleanInt = [self nextCleanInternal];
  return nextCleanInt == -1 ? 0x0000 : (unichar) nextCleanInt;
}


#line 519
- (NSString *)nextWithInt:(int)length {
  
#line 520
  if (pos_ + length > ((int) [((NSString *) nil_chk(in_)) length])) {
    @throw [self syntaxErrorWithNSString:[NSString stringWithFormat:@"%d is out of bounds", length]];
  }
  NSString *result = [in_ substring:pos_ endIndex:pos_ + length];
  pos_ += length;
  return result;
}


#line 544
- (NSString *)nextToWithNSString:(NSString *)excluded {
  
#line 545
  if (excluded == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"excluded == null"];
  }
  return [((NSString *) nil_chk([self nextToInternalWithNSString:excluded])) trim];
}


#line 554
- (NSString *)nextToWithChar:(unichar)excluded {
  
#line 555
  return [((NSString *) nil_chk([self nextToInternalWithNSString:[NSString valueOfChar:excluded]])) trim];
}


#line 563
- (void)skipPastWithNSString:(NSString *)thru {
  
#line 564
  int thruStart = [((NSString *) nil_chk(in_)) indexOfString:thru fromIndex:pos_];
  pos_ = thruStart == -1 ? ((int) [in_ length]) : (thruStart + ((int) [((NSString *) nil_chk(thru)) length]));
}


#line 573
- (unichar)skipToWithChar:(unichar)to {
  
#line 574
  int index = [((NSString *) nil_chk(in_)) indexOf:to fromIndex:pos_];
  if (index != -1) {
    pos_ = index;
    return to;
  }
  else {
    
#line 579
    return 0x0000;
  }
}


#line 587
- (void)back {
  if (--pos_ == -1) {
    pos_ = 0;
  }
}


#line 600
+ (int)dehexcharWithChar:(unichar)hex {
  
#line 601
  if (hex >= '0' && hex <= '9') {
    return hex - '0';
  }
  else
#line 603
  if (hex >= 'A' && hex <= 'F') {
    return hex - 'A' + 10;
  }
  else
#line 605
  if (hex >= 'a' && hex <= 'f') {
    return hex - 'a' + 10;
  }
  else {
    
#line 608
    return -1;
  }
}

- (void)copyAllFieldsTo:(FQJSONTokener *)other {
  [super copyAllFieldsTo:other];
  other->in_ = in_;
  other->pos_ = pos_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithNSString:", "JSONTokener", NULL, 0x1, NULL },
    { "nextValue", NULL, "Ljava.lang.Object;", 0x1, "Lcom.fq.lib.json.JSONException;" },
    { "nextCleanInternal", NULL, "I", 0x2, "Lcom.fq.lib.json.JSONException;" },
    { "skipToEndOfLine", NULL, "V", 0x2, NULL },
    { "nextStringWithChar:", "nextString", "Ljava.lang.String;", 0x1, "Lcom.fq.lib.json.JSONException;" },
    { "readEscapeCharacter", NULL, "C", 0x2, "Lcom.fq.lib.json.JSONException;" },
    { "readLiteral", NULL, "Ljava.lang.Object;", 0x2, "Lcom.fq.lib.json.JSONException;" },
    { "nextToInternalWithNSString:", "nextToInternal", "Ljava.lang.String;", 0x2, NULL },
    { "readObject", NULL, "Lcom.fq.lib.json.JSONObject;", 0x2, "Lcom.fq.lib.json.JSONException;" },
    { "readArray", NULL, "Lcom.fq.lib.json.JSONArray;", 0x2, "Lcom.fq.lib.json.JSONException;" },
    { "syntaxErrorWithNSString:", "syntaxError", "Lcom.fq.lib.json.JSONException;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "more", NULL, "Z", 0x1, NULL },
    { "next", NULL, "C", 0x1, NULL },
    { "nextWithChar:", "next", "C", 0x1, "Lcom.fq.lib.json.JSONException;" },
    { "nextClean", NULL, "C", 0x1, "Lcom.fq.lib.json.JSONException;" },
    { "nextWithInt:", "next", "Ljava.lang.String;", 0x1, "Lcom.fq.lib.json.JSONException;" },
    { "nextToWithNSString:", "nextTo", "Ljava.lang.String;", 0x1, NULL },
    { "nextToWithChar:", "nextTo", "Ljava.lang.String;", 0x1, NULL },
    { "skipPastWithNSString:", "skipPast", "V", 0x1, NULL },
    { "skipToWithChar:", "skipTo", "C", 0x1, NULL },
    { "back", NULL, "V", 0x1, NULL },
    { "dehexcharWithChar:", "dehexchar", "I", 0x9, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "in_", NULL, 0x12, "Ljava.lang.String;", NULL,  },
    { "pos_", NULL, 0x2, "I", NULL,  },
  };
  static J2ObjcClassInfo _FQJSONTokener = { "JSONTokener", "com.fq.lib.json", NULL, 0x1, 23, methods, 2, fields, 0, NULL};
  return &_FQJSONTokener;
}

@end
